## 1.2 手続きとそれが生成するプロセス
良いプログラマはプロセスが取るべき処理の流れを思い描けるようになる必要がある
この章ではプロセスの極度に単純化したパターンを扱っていく

### 1.2.1 線形再帰と反復
階乗をする関数について考える

```
(define (factorial n)
  (if (= n 1)
  1
  (* n (factorial (- n 1)))))
```
これを図式化すると下記のようになる

```
(factorial 6)
(* 6 (factorial 5))
(* 6 (* 5 (factorial 4)))
...
(* 6 (* 5 (* 4 (* 3 (* 2 1)))))
(* 6 (* 5 (* 4 (* 3 2))))
...
(* 6 120)
720
```

この流れは先に関数を展開したあとに縮約するで、遅延演算している形になる。

プロセスだと再帰プロセスと呼ばれる。この方式ではインタプリタはあとで実行する演算を記憶している必要がある。

nの数に応じてステップ数が増えるので線形再帰プロセスとよばれる。

違う書き方もできる

```
(define (factorial n)
  (fact-iter 1 1 n))

(define (fact-iter product counter max-count)
  (if (> counter max-count)
      product
      (fact-iter (* counter product)
      (* counter 1)
      max-count)))
```

これも図式化すると

```
(factorial 6)
(fact-iter 1 1 6)
(fact-iter 1 2 6)
(fact-iter 2 3 6)
(fact-iter 6 3 6)
...
(fact-iter 720 7 6)
```

前の計算結果を使って実行していく感じ。並列実行はしにくいかな。

これは反復プロセスと呼ぶ。このプロセスには状態変数を使いまわす。while文でのループみたいな感じかな。

nの数に応じてステップ数が増えるので線形反復プロセスとよばれる。

これらのプロセスの違いには違う見方があり、反復プロセスは途中でプロセスが終わってしまっても、計算再開時に終了時の変数の状態をインタプリタに渡して上げれば良い。再帰処理ではプログラマが意識しないで利用している追加情報があるため、再開は難しい。ポインタとかの情報かな？これは後程の章で。

注意として再帰プロセスと再帰手続きの概念の使い方が書いてある。

手続きについていうときは構文的に再帰処理が書かれているかを述べているかである。現にfact-iterは再帰手続きを使っているが、再帰プロセスではない。

再帰プロセスと反復プロセスについての厳密な違いを噛み砕くは徐々にやっていくことになりそう。
