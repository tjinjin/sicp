## 1.2 手続きとそれが生成するプロセス
良いプログラマはプロセスが取るべき処理の流れを思い描けるようになる必要がある
この章ではプロセスの極度に単純化したパターンを扱っていく

### 1.2.1 線形再帰と反復
階乗をする関数について考える

```
(define (factorial n)
  (if (= n 1)
  1
  (* n (factorial (- n 1)))))
```
これを図式化すると下記のようになる

```
(factorial 6)
(* 6 (factorial 5))
(* 6 (* 5 (factorial 4)))
...
(* 6 (* 5 (* 4 (* 3 (* 2 1)))))
(* 6 (* 5 (* 4 (* 3 2))))
...
(* 6 120)
720
```

この流れは先に関数を展開したあとに縮約するで、遅延演算している形になる。

プロセスだと再帰プロセスと呼ばれる。この方式ではインタプリタはあとで実行する演算を記憶している必要がある。

nの数に応じてステップ数が増えるので線形再帰プロセスとよばれる。

違う書き方もできる

```
(define (factorial n)
  (fact-iter 1 1 n))

(define (fact-iter product counter max-count)
  (if (> counter max-count)
      product
      (fact-iter (* counter product)
      (* counter 1)
      max-count)))
```

これも図式化すると

```
(factorial 6)
(fact-iter 1 1 6)
(fact-iter 1 2 6)
(fact-iter 2 3 6)
(fact-iter 6 3 6)
...
(fact-iter 720 7 6)
```

前の計算結果を使って実行していく感じ。並列実行はしにくいかな。

これは反復プロセスと呼ぶ。このプロセスには状態変数を使いまわす。while文でのループみたいな感じかな。

nの数に応じてステップ数が増えるので線形反復プロセスとよばれる。

これらのプロセスの違いには違う見方があり、反復プロセスは途中でプロセスが終わってしまっても、計算再開時に終了時の変数の状態をインタプリタに渡して上げれば良い。再帰処理ではプログラマが意識しないで利用している追加情報があるため、再開は難しい。ポインタとかの情報かな？これは後程の章で。

注意として再帰プロセスと再帰手続きの概念の使い方が書いてある。

手続きについていうときは構文的に再帰処理が書かれているかを述べているかである。現にfact-iterは再帰手続きを使っているが、再帰プロセスではない。

再帰プロセスと反復プロセスについての厳密な違いを噛み砕くは徐々にやっていくことになりそう。

### 1.2.2 木の再帰

フィボナッチ数列

```
(define (fib n)
  (cond ((= n 0) 0)
        ((= n 1) 1)
        (else (+ (fib (- n 1))
                 (fib (- n 2))))))
```

(fib 5)を計算するには(fib 4)と(fib 3)を計算する。これらのプロセスを展開すると木構造をしていて、枝はそれぞれのレベルで2つに分かれている。

ただしこの計算だと無駄が多い。入力に対して指数的に増大する。一方で必要な空間は入力に対して線形。計算のどの地点でも木の中で上にあるノードだけを記録しておけばいいから。一般に、木の再帰プロセスで必要なステップ数は木のノードに比例し、必要な空間は木の最大の深さに比例する

書いては見たもののよくわかっていない。

フィボナッチ数列は反復プロセスとして定式化できる。

```
(define (fib n)
  (fib-iter 1 0 n))
(define (fib-iter a b count)
  (if (= count 0)
      b
      (fib-iter (+ a b) a (- count 1))))
```

この反復プロセスだとステップ数がFib(n)と同等。対して再帰プロセスだとnに対して線形となる。木の再帰はプログラムを素直に理解するにはとてもわかりやすい。再帰でのフィボナッチ数列は数式をそのまま落とし込むことができる。対して、反復では計算が3つの状態変数を使った反復として書き直せることに気づく必要がある

#### 両替パターンの計算
$1を両替するパターンはどれだけあるか。50セント、25セント、10セント、5セント、1セントを利用できる

使えるコインの種類に決まった順番があるものとするとn種類のコインを使って金額aを両替するパターンは

- 一つ目の種類のコイン以外のすべての種類のコインを使って金額aを両替するやり方のパターン数
- n種類の硬貨すべてを使って、金額a-dを両替するやり方のパターン数。dは一つ目の種類のコインの額面とする

> たとえば、1000円札を500円・100円・50円・10円・5円・1円で両替する方法の数は、
> 500円を使う場合と使わない場合にわけられるので
> 1000円札を100円・50円・10円・5円・1円で両替する方法の数
> ＋
> 500円を500円・100円・50円・10円・5円・1円で両替する方法の数（残りの500円は常に500円玉になっているとみなす）

とのこと。具体例だすとわかりやすい。500円を使わないパターンはそのまま計算すればいい。500円を使うパターンは1枚500円を使ったとして残りのパターンを出せばいい。

仮に10セントの両替を5セントと1セントでやるとする。まず、5を使わない場合は1で10枚、5を使う場合は、のこり5なのでそこで、5を使う場合と使わないパターンで計算する。なので木構造の右側のノードがどんどん細分化されていくイメージだと思う。

上記から下記が求められるらしい

- もしaがちょうど0なら、両替パターンは1と数える
- もしaが0未満なら、両替パターンは0と数える
- もしnが0なら、両替パターンは0と数える


これらをコードにすると

```
(define (count-change amount)
  (cc amount 5))

(define (cc amount kinds-of-coins)
  (cond ((= amount 0) 1)
        ((or (< amount 0) (= kinds-of-coins 0)) 0)
        (else (+ (cc amount
                     (- kinds-of-coins 1))
                 (cc (- amount
                        (first-denomination kinds-of-coins))
                     kinds-of-coins)))))

(define (first-denomination kinds-of-coins)
  (cond ((= kinds-of-coins 1) 1)
        ((= kinds-of-coins 2) 5)
        ((= kinds-of-coins 3) 10)
        ((= kinds-of-coins 4) 25)
        ((= kinds-of-coins 5) 50)))

(count-change 100)
;> 292
```

この例は再帰プロセスで冗長だが、わかりやすいのでコンパイラ側でメモ化なりテーブル可をして計算速度を上げる提案がされているそう

この両替問題は数学ガール第10章の分割数に載っている
