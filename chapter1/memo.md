## 1.1
### 1.1.1 式
前置記法の話

```
> (* 25 4 12)
1200
> (+ (* 3 5)(- 10 6))
```

プリティプリントという記法。人がわかりやすいように演算子を縦にそろえて書く

### 1.1.2 命名と環境
`define` を使って変数を定義する？

```
> (define pi 3.141419)
> (define radius 10)
> (* pi (* radius radius))
314.159
```

### 1.1.3 組み合わせの評価
組み合わせの評価は主に2ステップ

- 組み合わせの部分式を評価
- 部分式の左にある演算子の手続きを、部分式に適用する

これらは本質的に再帰的な処理。

```
(* (+ 2 (* 4 6))
   (+ 3 5 7))
```

これをツリーで表すとよい。終端ノードから上に向かって伝わっていく様子は木の集積（tree accumulation）と呼ばれる

組み合わせの部分式を評価していくとあるタイミングで、数値や演算子、その他の名前というような基本式になる。これらを下記のように扱っている

- 数字の値は値として扱う
- 組み込み演算子は機械語の列で、それに対応する操作を行う
- その他の名前は、現在の環境で名付けられたオブジェクトとみなす

組み込み演算子はある意味オブジェクトとみなすこともできる。

上の3ステップは定義については扱っていない。例えば`(define x 3)`はあくまで記号xと値を関連付けること。

### 1.1.4 複合手続きモデル

```
(define (square x) (* x x))
```

複合演算に名前を付けたもの。複合手続きと呼ぶ。

```
(define (<名前> <仮引数>)
  <本体>)
```

のような形式になる

重ねることもできる


```
(define (sum-of-squares x y)
  (x (square x) (square y)))
(sum-of-squares 3 4)
25
```

```
(define (f a)
  (sum-of-squares (+ a 1)(* a 2)))
(f 5)
136
```

複合手続きは基本手続きとまったく同じように使うことができ、見分けることはできない

### 1.1.5 手続き適用の置換モデル
複合手続きでインタプリタは組み合わせの各要素を評価し、手続きを引数に適用する流れになる

  複合手続きを引数に適用するには、手続きの本体に出てくる仮引数を対応する引数で置き換えてそれを評価する

ex> (f 5)

まず本体を取得

(sum-of-squares (+ a 1) (* a 2))

次に仮引数を置き換える

(sum-of-squares (+ 5 1) (* 5 2))

手続きを実行できるように演算子を計算して手続きの形にする

(+ (square 6) (square 10))

これをまた置き換える

(+ (* 6 6) (* 10 10))
(+ 36 100)
136

この手順は置換モデル（substitution model）と呼ばれる。この段階ではあくまでモデルで、これがインタプリタの動きではないので注意

```
評価手順について形式的に考えるための最初の一歩となるものに過ぎません。一般に、科学や工学で現象をモデル化するときには、単純化した不完全なモデルから始めます。物事を詳細に調べていくにつれ、これらの単純なモデルは不適切になり、より精密なモデルで置き換えられな帰ればならない。
```

単純化するってことは要素を削ぎ落とすことだもんね。

遅延？モデル（値が必要になるまで非演算子を計算しない

```
(sum-of-squares (+ 5 1) (* 5 2))
(+ (square (+ 5 1)) (square (* 5 2)) )
(+ (* (+ 5 1) (+ 5 1)) (* (* 5 2) (* 5 2)) )
(+         (* 6 6)            (* 10 10))
(+ 36 100)
136
```

後者の完全に展開してから簡約するというものは*正規順序評価* (normal-order evaluation)と呼ばれ、インタプリタが実際に使っている引数を評価してから適用するという方法は*適用順序評価*(applicative-order evaluation)と呼ばれる。置換によってモデル化できる場合は正規順序評価と適用順序評価は同じ値になる。
Lispでは適用順序評価を使っている。

### 1.1.6 条件式と述語

場合分け（case analysis）

```
(define (abs x)
  (cond ((> x 0) x)
        ((= x 0) 0)
        ((< x 0) (- x))))
```

一般式では下記の形式

```
(cond (<p1> <e1>)
      (<p2> <e2>)
      ...
      (<pn> <en>))
```

記号condに続く節（clause）という括弧のペアの列によって構成される。
ペアの最初の式は述語（predicate）―値が真偽で解釈される式

`<p1>`から解釈され、偽なら`<p2>`へと真が見つかるまで続く。見つかると結果式`<e>`を返す
述語は手続きに対しても利用できる`(< x 0)`など

以下のようにも書ける

```
(define (abs x)
  (cond ((< x 0) (- x))
        (else x)))
```

ifだと下記のようになる

```
(define (abs x)
  (if (< x 0)
       (- x)
       x))
```

ifは場合分けが2つの場合からなる場合に使える。

```
(if <predicate> <consequent> <alternative>)
```

#### 論理複合演算
- (and <e1> ... <en>)
  - 左から右に一つずつ評価する。どれか一つが偽と評価されると全体として偽になり、残りの<e>は評価されない
- (or <e1> ... <en>)
  - 左から右に一つずつ評価する。<e>のどれか一つが真と評価されると、全体として真になり、残りは評価されない
- (not <e>)
  - 式が真なら偽に、偽なら真になる

andとorは特殊形式で手続きではない（最後まで評価されないから）。notは手続き

```
(define (>= x y) (or (> x y) (= x y)))
(define (>= x y) (not (< x y)))
```
